package p2p

import (
	"testing"
	"time"

	"github.com/pokt-network/pocket/p2p/types"
	shared "github.com/pokt-network/pocket/shared/config"
)

func TestNetwork_Ping(t *testing.T) {
	m := newP2PModule()
	m.config = &shared.P2PConfig{
		MaxInbound:       100,
		MaxOutbound:      100,
		BufferSize:       1024 * 4,
		WireHeaderLength: 8,
		TimeoutInMs:      200,
	}

	m.configure("tcp", "0.0.0.0:4032", "0.0.0.0:4032", []string{})
	m.init()

	err := m.init()

	if err != nil {
		t.Logf("Error: failed to initialize gater. %s", err.Error())
	}

	go m.listen()
	_, waiting := <-m.ready

	if waiting {
		t.Errorf("Request error: gater still not started after Listen")
	}

	addr := "127.0.0.1:2313"
	ready, _, data, respond := ListenAndServe(addr, int(m.config.BufferSize))

	select {
	case v := <-ready:
		if v == 0 {
			t.Errorf("Send error: could not start recipient server")
		}
	}

	// ping addr
	errors := make(chan error)
	responses := make(chan bool)
	go func() {
		t.Logf("Pinging...")
		alive, err := m.ping(addr)
		if err != nil {
			t.Logf("Ping: failed. %s", err.Error())
			errors <- err
		}
		t.Logf("Ping: OK")
		responses <- alive
	}()

	<-time.After(time.Microsecond * 10)
	t.Logf("Receiving...")
	c := &wireCodec{}

	select {
	case err := <-errors:
		t.Errorf("err: %s", err.Error())

	case d := <-data:
		{
			t.Logf("Received: OK")
			nonce, encoding, buff, _, err := c.decode(d.buff)
			if err != nil {
				t.Errorf("Ping error: Encountered error while decoding received ping: %s", err.Error())
			}

			m, err := m.c.Decode(buff)
			if err != nil {
				t.Errorf("Ping error: failed to decode ping on receipt (domain codec). Encountered error: %s", err.Error())
			}

			msg := m.(types.P2PMessage)

			if msg.Topic != common.PocketTopic_P2P_PING {
				t.Errorf("Ping error: peer expecte to receive ping message, got %s instead", msg.Topic)
			}

			pongmsg := Message(int32(nonce), 0, types.PocketTopic_P2P_PONG, addr, m.address)
			encoded, err := m.c.encode(pongmsg)

			if err != nil {
				t.Errorf("Ping error: Encountered error while encoding pong message: %s", err.Error())
			}

			respond <- c.encode(encoding, false, nonce, encoded, false)
		}

	case alive, open := <-responses:
		if !open {
			err := <-errors
			t.Errorf("Ping error: error while receiving a response: %s", err.Error())
		}

		if alive != true {
			t.Errorf("Ping error: expected peer to be alive, got the following instead: alive=%v", alive)
		}

	}
}

func TestNetwork_Pong(t *testing.T) {
	g := newP2PModule()

	g.configure("tcp", "0.0.0.0:4033", "0.0.0.0:4033", []string{})

	err := g.init()
	if err != nil {
		t.Logf("Error: failed to initialize gater. %s", err.Error())
	}

	msg := *Message(0, 0, types.PocketTopic_P2P_PONG, "", g.address)

	go g.listen()
	_, waiting := <-g.ready

	if waiting {
		t.Errorf("Request error: gater still not started after Listen")
	}

	addr := "127.0.0.1:22312"
	ready, _, data, _ := ListenAndServe(addr, ReadBufferSize)

	select {
	case v := <-ready:
		if v == 0 {
			t.Errorf("Send error: could not start recipient server")
		}
	}

	// ping addr
	var perr *error

	pongnonce := uint32(1)
	signals := make(chan int)
	go func() {
		msg := Message(0, 0, types.PocketTopic_P2P_PING, "", g.address)

		err := g.pong(*msg)
		if err != nil {
			perr = &err
		}
		signals <- 1
	}()

	<-signals

	if perr != nil {
		t.Errorf("Pong error: failed to send a pong message. Error: %s", (*perr).Error())
	}

	d := <-data

	nonce, _, buff, _, err := (&wireCodec{}).decode(d.buff)
	if err != nil {
		t.Errorf("Pong error: faield to decode wire bytes received from pong message. Error: %s", err.Error())
	}

	decoded, err := g.c.decode(buff)
	if err != nil {
		t.Errorf("Pong error: failed to decode received pong message. Error: %s", err.Error())
	}

	msg = decoded.(types.NetworkMessage)
	if msg.Topic != types.PocketTopic_P2P_PONG {
		t.Errorf("Pong error: expected to receive a message with action=%s, got: %s instead.", types.PocketTopic_P2P_PONG, msg.Topic)
	}

	if nonce != 1 {
		t.Errorf("Pong error: wrong nonce, expected %d, got: %d", pongnonce, nonce)
	}
}
